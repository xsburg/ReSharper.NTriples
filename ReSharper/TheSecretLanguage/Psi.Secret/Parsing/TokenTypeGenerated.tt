<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ assembly name="System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ assembly name="System.Xml.Linq, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml.Linq" #>
<#
    var tokensFileName = "Tokens.xml";

    if (!Path.IsPathRooted(tokensFileName))
    {
        var thisDir = new DirectoryInfo(this.Host.ResolvePath(""));
        tokensFileName = Path.Combine(thisDir.FullName, tokensFileName);
    }

    var xdoc = XDocument.Load(tokensFileName);
    var root = xdoc.Root;
    var tokeTypeNamespace = root.Attribute("TokenTypeNamespace").Value;
    var tokenTypeClass = root.Attribute("TokenTypeClass").Value;
    var keywordNodeType = root.Attribute("KeywordNodeType").Value;
    var keywordTokenElement = root.Attribute("KeywordTokenElement").Value;
    var tokenNodeType = root.Attribute("TokenNodeType").Value;
    var tokenTokenElement = root.Attribute("TokenTokenElement").Value;
    var elements = root.Elements().Select(
        x => new
            {
                Type = this.GetElementType(x.Name.LocalName),
                Name = x.Attribute("name").Value,
                Representation = x.Attribute("representation").Value
            }).ToArray();
    #>
//------------------------------------------------------------------------------
// <auto-generated>
//     Generated by TokenGenerator
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using JetBrains.ReSharper.Psi.ExtensionsAPI.Tree;
using JetBrains.Text;
using JetBrains.ReSharper.Psi.Parsing;

namespace <#=tokeTypeNamespace #>
{
    public static partial class <#=tokenTypeClass #>
    {
<#
foreach (var element in elements)
{
    var nodeType = element.Type == ElementType.Keyword
                       ? keywordNodeType
                       : tokenNodeType;
    var tokenElement = element.Type == ElementType.Keyword
                           ? keywordTokenElement
                           : tokenTokenElement;
    var name = element.Name;
    var upperName = this.ToUpperCamelCase(element.Name);
    #>
        #region <#=name #>
        private class <#=upperName #>NodeType : <#=nodeType #>
        {
            public <#=upperName #>NodeType(): base ("<#=name #>", "<#=element.Representation #>") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new <#=upperName #>TokenElement(this);
            }
        }
        private class <#=upperName #>TokenElement : <#=tokenElement #>
        {
            public <#=upperName #>TokenElement(<#=upperName #>NodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType <#=element.Name #> = new <#=upperName #>NodeType();
        #endregion

<#
}
#>
    }
}
 
<#+

    private enum ElementType
    {
        Token,
        Keyword
    }

    private ElementType GetElementType(string elementName)
    {
        ElementType result;
        if (!Enum.TryParse<ElementType>(elementName, true, out result))
        {
            throw new ArgumentException();
        }

        return result;
    }

    private string ToUpperCamelCase(string name)
    {
        name = Regex.Replace(name.ToLower(), @"_([a-zA-Z0-9])", m => m.Groups[1].Value.ToUpper());
        return name[0].ToString().ToUpper() + name.Substring(1);
    }

    #>